<application>
  <component name="AppStorage">
    <histories>
      <item value="dummy" />
      <item value="Wait queue node class. &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A &quot;status&quot; field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait. &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field. &lt;pre&gt; +------+ prev +-----+ +-----+ head | | &lt;---- | | &lt;---- | | tail +------+ +-----+ +-----+ &lt;pre&gt; &lt;p&gt;Insertion into a CLH queue requires only a single atomic operation on &quot;tail&quot;, so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeuing involves only updating the &quot;head&quot;. However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts. &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at http:www.cs.rochester.eduuscottsynchronization &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the &quot;next&quot; fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated &quot;tail&quot; when a node's successor appears to be null. (Or, said differently, the next-links are an optimization so that we don't usually need a backward scan.) &lt;p&gt;Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility. &lt;p&gt;CLH queues need a dummy header node to get started. But we don't create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention. &lt;p&gt;Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on. &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class." />
      <item value="predecessor" />
      <item value="Try the fast path of enq; backup to full enq on failure" />
      <item value="enqueues" />
      <item value="Convenience" />
      <item value="acquire" />
      <item value="Specifies that this bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency. If exactly one 'primary' bean exists among the candidates, it will be the autowired value." />
      <item value="Specifies that this bean should be given preference when multiple" />
      <item value="in favor of" />
      <item value="Alternatively" />
      <item value="Some shortcuts in this course may conflict with the system or other application shortcuts. In this case, you can click the problematic shortcut in the text of the lesson. The opened popup will show you the action name and alternative shortcuts. You will be able to apply the action or assign a new shortcut." />
      <item value="You are likely reading this `README.md` during the learning project initialization. Usually, `indexing` is the most time-consuming operation during project initialization. The IDE will need to collect information about your environment, project, libraries, and construct internal representation. It is needed for fast navigation and search. The `Navigation` module in this course will show how to use it." />
      <item value="The `Learn` tool window contains several modules with the corresponding sets of lessons that you can take in any order. When you finish studying a lesson, it will be marked as completed. You can use a completed lesson for your reference or restart it if you want to refresh your knowledge. Even though a lesson looks familiar to you, give it a try: you may discover helpful examples and unknown shortcuts of the features you actively use!" />
      <item value="Interactive" />
      <item value="Meet the Interactive Feature Trainer" />
      <item value="Sql Session Template" />
      <item value="The default implementation for the DTMManager. %REVIEW% There is currently a reentrancy issue, since the finalizer for XRTreeFrag (which runs in the GC thread) wants to call DTMManager.release(), and may do so at the same time that the main transformation thread is accessing the manager. Our current solution is to make most of the manager's methods &lt;code&gt;synchronized&lt;code&gt;. Early tests suggest that doing so is not causing a significant performance hit in Xalan. However, it should be noted that there is a possible alternative solution: rewrite release() so it merely posts a request for release onto a threadsafe queue, and explicitly process that queue on an infrequent basis during main-thread activity (eg, when getDTM() is invoked). The downside of that solution would be a greater delay before the DTM's storage is actually released for reuse." />
      <item value="The lock protecting all mutators. (We have a mild preference for builtin monitors over ReentrantLock when either will do.)" />
      <item value="The lock protecting all mutators." />
      <item value="Creates a new {@code CyclicBarrier} that will trip when the given number of parties (threads) are waiting upon it, and which will execute the given barrier action when the barrier is tripped, performed by the last thread entering the barrier" />
      <item value="predNext is the apparent node to unsplice. CASes below will fail if not, in which case, we lost race vs another cancel or signal, so no further action is necessary." />
      <item value="predNext is the apparent node to unsplice" />
      <item value="unsplice" />
      <item value="Thread to unpark is held in successor, which is normally just the next node. But if cancelled or apparently null, traverse backwards from tail to find the actual non-cancelled successor" />
      <item value="If status is negative (i.e., possibly needing signal) try to clear in anticipation of signalling. It is OK if this fails or if status is changed by waiting thread." />
      <item value="If status is negative (i.e., possibly needing signal) try to clear in anticipation of signalling." />
      <item value="Implemented by unblocking one or more threads if {@link tryRelease} returns true" />
      <item value="exclusive" />
      <item value="indicate" />
      <item value="This method does &lt;em&gt;not&lt;em&gt; report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread upon return" />
      <item value="spuriously" />
      <item value="Some other thread {@linkplain Threadinterrupt interrupts} the current thread" />
      <item value="it is consumed and the call returns immediately" />
      <item value="If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens" />
      <item value="Indicate that we need a signal, but don't park yet. Caller will need to retry to make sure it cannot acquire before parking" />
      <item value="This node is currently on a condition queue. It will not be used as a sync queue node until transferred, at which time the status will be set to 0. (Use of this value here has nothing to do with the other uses of the field, but simplifies mechanics" />
      <item value="Predecessor was cancelled. Skip over predecessors and indicate retry" />
      <item value="if thread should block" />
      <item value="Returns true if thread should block" />
      <item value="This is the main signal control in all acquire loops" />
      <item value="This is the main signal如果线程阻塞，则返回true control in all acquire loops" />
      <item value="Checks and updates status for a node that failed to acquire" />
      <item value="Checks and updates status for a node that failed to acquire. Returns true if thread should block. This is the main signal control in all acquire loops. Requires that pred == node.prev" />
      <item value="Wakes up node's successor, if one exists" />
      <item value="Otherwise wake it up to propagate" />
      <item value="so it will get one. Otherwise wake it up to propagate" />
      <item value="If successor needs signal, try to set pred's next-link" />
      <item value="predNext is the apparent node to unsplice. CASes below will fail if not, in which case, we lost race vs another cancel or signal, so no further action is necessary" />
      <item value="This node is cancelled due to timeout or interrupt. Nodes never leave this state. In particular, a thread with cancelled node never again blocks" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="134" />
        <entry key="ENGLISH" value="134" />
        <entry key="CZECH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1632635413716" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>