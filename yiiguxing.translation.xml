<application>
  <component name="AppStorage">
    <histories>
      <item value="Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0" />
      <item value="We want to clear any interrupt we may have received from cancel(true). However, it is permissible to use interrupts as an independent mechanism for a task to communicate with its caller, and there is no way to clear only the cancellation interrupt" />
      <item value="Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled" />
      <item value="Treiber stack" />
      <item value="Treiber" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us. Let's spin-wait patiently" />
      <item value="wait out pending interrupt" />
      <item value="Ensures that any interrupt from a possible cancel(true) is only delivered to a task while in run or runAndReset" />
      <item value="culling" />
      <item value="Are workers subject to culling" />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Abruptly" />
      <item value="This operation has memory semantics" />
      <item value="precheck that t is startable" />
      <item value="If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="Inserts the specified element into this queue, if another thread is waiting to receive it" />
      <item value="completed Abruptly" />
      <item value="Bit field accessors that don't require unpacking ctl. These depend on the bit layout and on workerCount being never negative" />
      <item value="If pool is stopping, ensure thread is interrupted; if not, ensure thread is not interrupted. This requires a recheck in second case to deal with shutdownNow race while clearing interrupt" />
      <item value="Eligible to terminate" />
      <item value="terminate" />
      <item value="Eligible" />
      <item value="If true, interrupt at most one worker" />
      <item value="Transitions to TERMINATED state" />
      <item value="If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor" />
      <item value="rechecks for termination, in case the existence of this worker was holding up termination" />
      <item value="Check if queue empty only if necessary" />
      <item value="because existing ones died since last checking" />
      <item value="Inserts the specified element into this queue, if another thread is waiting to receive it." />
      <item value="1. If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task. The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false. 2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none. 3. If we cannot queue task, then we try to add a new thread. If it fails, we know we are shut down or saturated and so reject the task." />
      <item value="TIDYING" />
      <item value="Indicates the 'role' hint for a given bean. &lt;p&gt;May be used on any class directly or indirectly annotated with {@link org.springframework.stereotype.Component} or on methods annotated with {@link Bean}. &lt;p&gt;If this annotation is not present on a Component or Bean definition, the default value of {@link BeanDefinitionROLE_APPLICATION} will apply. &lt;p&gt;If Role is present on a {@link Configuration @Configuration} class, this indicates the role of the configuration class bean definition and does not cascade to all @{@code Bean} methods defined within. This behavior is different than that of the @{@link Lazy} annotation, for example." />
      <item value="Second try is the caching operation on the target class" />
      <item value="First try is the method in the target class" />
      <item value="remaining" />
      <item value="If status is negative (i.e., possibly needing signal) try to clear in anticipation of signalling. It is OK if this fails or if status is changed by waiting thread" />
      <item value="unparking" />
      <item value="This node has already set status asking a release to signal it, so it can safely park." />
      <item value="waitStatus value to indicate successor's thread needs unparking" />
      <item value="park" />
      <item value="successor" />
      <item value="should Park After Failed Acquire" />
      <item value="accurate" />
      <item value="The correctness of this depends on head being initialized before tail and on head.next being accurate if the current thread is first in queue" />
      <item value="Read fields in reverse initialization order" />
      <item value="Queries whether any threads have been waiting to acquire longer than the current thread." />
      <item value="dummy" />
      <item value="Wait queue node class. &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A &quot;status&quot; field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait. &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field. &lt;pre&gt; +------+ prev +-----+ +-----+ head | | &lt;---- | | &lt;---- | | tail +------+ +-----+ +-----+ &lt;pre&gt; &lt;p&gt;Insertion into a CLH queue requires only a single atomic operation on &quot;tail&quot;, so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeuing involves only updating the &quot;head&quot;. However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts. &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at http:www.cs.rochester.eduuscottsynchronization &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the &quot;next&quot; fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated &quot;tail&quot; when a node's successor appears to be null. (Or, said differently, the next-links are an optimization so that we don't usually need a backward scan.) &lt;p&gt;Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility. &lt;p&gt;CLH queues need a dummy header node to get started. But we don't create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention. &lt;p&gt;Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on. &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="188" />
        <entry key="ENGLISH" value="185" />
        <entry key="GERMAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1635233133748" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>