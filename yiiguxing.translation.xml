<application>
  <component name="AppStorage">
    <histories>
      <item value="canonical" />
      <item value="Initialize transaction synchronization as appropriate" />
      <item value="Standard transaction demarcation with getTransaction" />
      <item value="Semantics" />
      <item value="definitive" />
      <item value="We have fallen off list" />
      <item value="We have fallen off list. If tail is unchanged, it will also be off-list, in which case we need to jump to head, from which all live nodes are always reachable. Else the new tail is a better bet" />
      <item value="hop two nodes at a time" />
      <item value="the command to execute when the barrier is tripped" />
      <item value="Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http:en.wikipedia.orgwikiPoisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) factorial(k)). The first values are:" />
      <item value="Parses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="arses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="sifts" />
      <item value="retain" />
      <item value="don't retain ref while waiting" />
      <item value="Constrains the values of all delays in the queue to be within Long.MAX_VALUE of each other, to avoid overflow in compareTo. This may occur if a task is eligible to be dequeued, but has not yet been, while some other task is added with a delay of Long.MAX_VALUE" />
      <item value="Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0" />
      <item value="We want to clear any interrupt we may have received from cancel(true). However, it is permissible to use interrupts as an independent mechanism for a task to communicate with its caller, and there is no way to clear only the cancellation interrupt" />
      <item value="Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled" />
      <item value="Treiber stack" />
      <item value="Treiber" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us. Let's spin-wait patiently" />
      <item value="wait out pending interrupt" />
      <item value="Ensures that any interrupt from a possible cancel(true) is only delivered to a task while in run or runAndReset" />
      <item value="culling" />
      <item value="Are workers subject to culling" />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Abruptly" />
      <item value="This operation has memory semantics" />
      <item value="precheck that t is startable" />
      <item value="If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="Inserts the specified element into this queue, if another thread is waiting to receive it" />
      <item value="completed Abruptly" />
      <item value="Bit field accessors that don't require unpacking ctl. These depend on the bit layout and on workerCount being never negative" />
      <item value="If pool is stopping, ensure thread is interrupted; if not, ensure thread is not interrupted. This requires a recheck in second case to deal with shutdownNow race while clearing interrupt" />
      <item value="Eligible to terminate" />
      <item value="terminate" />
      <item value="Eligible" />
      <item value="If true, interrupt at most one worker" />
      <item value="Transitions to TERMINATED state" />
      <item value="If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor" />
      <item value="rechecks for termination, in case the existence of this worker was holding up termination" />
      <item value="Check if queue empty only if necessary" />
      <item value="because existing ones died since last checking" />
      <item value="Inserts the specified element into this queue, if another thread is waiting to receive it." />
      <item value="1. If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task. The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add threads when it shouldn't, by returning false. 2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none. 3. If we cannot queue task, then we try to add a new thread. If it fails, we know we are shut down or saturated and so reject the task." />
      <item value="TIDYING" />
      <item value="Indicates the 'role' hint for a given bean. &lt;p&gt;May be used on any class directly or indirectly annotated with {@link org.springframework.stereotype.Component} or on methods annotated with {@link Bean}. &lt;p&gt;If this annotation is not present on a Component or Bean definition, the default value of {@link BeanDefinitionROLE_APPLICATION} will apply. &lt;p&gt;If Role is present on a {@link Configuration @Configuration} class, this indicates the role of the configuration class bean definition and does not cascade to all @{@code Bean} methods defined within. This behavior is different than that of the @{@link Lazy} annotation, for example." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="204" />
        <entry key="ENGLISH" value="201" />
        <entry key="GERMAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1636804820503" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>