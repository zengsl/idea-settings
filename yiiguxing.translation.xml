<application>
  <component name="AppStorage">
    <histories>
      <item value="The range of valid ports, from bind_port to end_port" />
      <item value="Minimum number of initial members to get a response from" />
      <item value="While String is the easiest way to manipulate chars ( search, substrings, etc), it is known to not be the most efficient solution - Strings are designed as immutable and secure objects" />
      <item value="Utilities" />
      <item value="Utilities to manipulate char chunks" />
      <item value="Preserve behavioral compatibility with AbstractCollection, even if c.contains() throws" />
      <item value="Externalizable" />
      <item value="canonical" />
      <item value="Initialize transaction synchronization as appropriate" />
      <item value="Standard transaction demarcation with getTransaction" />
      <item value="Semantics" />
      <item value="definitive" />
      <item value="We have fallen off list" />
      <item value="We have fallen off list. If tail is unchanged, it will also be off-list, in which case we need to jump to head, from which all live nodes are always reachable. Else the new tail is a better bet" />
      <item value="hop two nodes at a time" />
      <item value="the command to execute when the barrier is tripped" />
      <item value="Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http:en.wikipedia.orgwikiPoisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) factorial(k)). The first values are:" />
      <item value="Parses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="arses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="sifts" />
      <item value="retain" />
      <item value="don't retain ref while waiting" />
      <item value="Constrains the values of all delays in the queue to be within Long.MAX_VALUE of each other, to avoid overflow in compareTo. This may occur if a task is eligible to be dequeued, but has not yet been, while some other task is added with a delay of Long.MAX_VALUE" />
      <item value="Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0" />
      <item value="We want to clear any interrupt we may have received from cancel(true). However, it is permissible to use interrupts as an independent mechanism for a task to communicate with its caller, and there is no way to clear only the cancellation interrupt" />
      <item value="Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled" />
      <item value="Treiber stack" />
      <item value="Treiber" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us. Let's spin-wait patiently" />
      <item value="wait out pending interrupt" />
      <item value="Ensures that any interrupt from a possible cancel(true) is only delivered to a task while in run or runAndReset" />
      <item value="culling" />
      <item value="Are workers subject to culling" />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Abruptly" />
      <item value="This operation has memory semantics" />
      <item value="precheck that t is startable" />
      <item value="If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="Inserts the specified element into this queue, if another thread is waiting to receive it" />
      <item value="completed Abruptly" />
      <item value="Bit field accessors that don't require unpacking ctl. These depend on the bit layout and on workerCount being never negative" />
      <item value="If pool is stopping, ensure thread is interrupted; if not, ensure thread is not interrupted. This requires a recheck in second case to deal with shutdownNow race while clearing interrupt" />
      <item value="Eligible to terminate" />
      <item value="terminate" />
      <item value="Eligible" />
      <item value="If true, interrupt at most one worker" />
      <item value="Transitions to TERMINATED state" />
      <item value="If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="211" />
        <entry key="ENGLISH" value="208" />
        <entry key="GERMAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1638514293707" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>