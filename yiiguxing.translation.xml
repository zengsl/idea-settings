<application>
  <component name="AppStorage">
    <histories>
      <item value="Interrupts this thread. Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown. If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. If this thread is blocked in an IO operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException. If this thread is blocked in a java.nio.channels.Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked. If none of the previous conditions hold then this thread's interrupt status will be set. Interrupting a thread that is not alive need not have any effect." />
      <item value="Attempts to cancel execution of this task. This attempt will fail if the task has already completed, has already been cancelled, or could not be cancelled for some other reason. If successful, and this task has not started when cancel is called, this task should never run. If the task has already started, then the mayInterruptIfRunning parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task. After this method returns, subsequent calls to isDone will always return true. Subsequent calls to isCancelled will always return true if this method returned true." />
      <item value="Main entry point of font selector logic. Contains reusable FontSet and collection of PdfFonts. FontProvider depends on PdfDocument due to PdfFont, so it cannot be reused for different documents unless reset with reset() or recreated with getFontSet(). In the former case the FontSelectorCache is reused and in the latter it's reinitialised. FontProvider the only end point for creating PdfFont. It is allowed to use only one FontProvider per document. If additional fonts per element needed, another instance of FontSet can be used. For more details see com.itextpdf.layout.properties.Property.FONT_SET, getPdfFont(FontInfo, FontSet), getStrategy(String, List, FontCharacteristics, FontSet). Note, FontProvider does not close created FontPrograms, because of possible conflicts with FontCache." />
      <item value="Switch User processing filter responsible for user context switching. This filter is similar to Unix 'su' however for Spring Security-managed web applications. A common use-case for this feature is the ability to allow higher-authority users (e.g. ROLE_ADMIN) to switch to a regular user (e.g. ROLE_USER). This filter assumes that the user performing the switch will be required to be logged in as normal (i.e. as a ROLE_ADMIN user). The user will then access a pagecontroller that enables the administrator to specify who they wish to become (see switchUserUrl). Note: This URL will be required to have appropriate security constraints configured so that only users of that role can access it (e.g. ROLE_ADMIN). On a successful switch, the user's SecurityContext will be updated to reflect the specified user and will also contain an additional SwitchUserGrantedAuthority which contains the original user. Before switching, a check will be made on whether the user is already currently switched, and any current switch will be exited to prevent &quot;nested&quot; switches. To 'exit' from a user context, the user needs to access a URL (see exitUserUrl) that will switch back to the original user as identified by the ROLE_PREVIOUS_ADMINISTRATOR. To configure the Switch User Processing Filter, create a bean definition for the Switch User processing filter and add to the filterChainProxy. Note that the filter must come after the FilterSecurityInteceptor in the chain, in order to apply the correct constraints to the switchUserUrl. Example: &lt;bean id=&quot;switchUserProcessingFilter&quot; class=&quot;org.springframework.security.web.authentication.switchuser.SwitchUserFilter&quot;&gt; &lt;property name=&quot;userDetailsService&quot; ref=&quot;userDetailsService&quot; &gt; &lt;property name=&quot;switchUserUrl&quot; value=&quot;loginimpersonate&quot; &gt; &lt;property name=&quot;exitUserUrl&quot; value=&quot;logoutimpersonate&quot; &gt; &lt;property name=&quot;targetUrl&quot; value=&quot;index.jsp&quot; &gt; &lt;bean&gt;" />
      <item value="Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects." />
      <item value="This is a short-circuiting stateful intermediate operation" />
      <item value="This is a short-circuiting stateful intermediate operation." />
      <item value="Returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of a subset of elements taken from this stream that match the given predicate. If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate. If this stream is unordered, and some (but not all) elements of this stream match the given predicate, then the behavior of this operation is nondeterministic; it is free to take any subset of matching elements (which includes the empty set). Independent of whether this stream is ordered or unordered if all elements of this stream match the given predicate then this operation takes all elements (the result is the same as the input), or if no elements of the stream match the given predicate then no elements are taken (the result is an empty stream)." />
      <item value="Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)" />
      <item value="Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method" />
      <item value="Streams have a close() method and implement AutoCloseable. Operating on a stream after it has been closed will throw IllegalStateException. Most stream instances do not actually need to be closed after use, as they are backed by collections, arrays, or generating functions, which require no special resource management. Generally, only streams whose source is an IO channel, such as those returned by Files.lines(Path), will require closing. If a stream does require closing, it must be opened as a resource within a try-with-resources statement or similar control structure to ensure that it is closed promptly after its operations have completed." />
      <item value="Streams have a close() method and implement AutoCloseable. Operating on a stream after it has been closed will throw IllegalStateException. Most stream instances do not actually need to be closed after use, as they are backed by collections, arrays, or generating functions, which require no special resource management. Generally, only streams whose source is an IO channel, such as those returned by Files.lines(Path), will require closing. If a stream does require closing, it must be opened as a resource within a try-with-resources statement or similar control structure to ensure that it is closed promptly after its operations have completed" />
      <item value="A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, &quot;forked&quot; streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases." />
      <item value="Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null." />
      <item value="in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline)." />
      <item value="must be non-interfering (they do not modify the stream source); and" />
      <item value="must be non-interfering (they do not modify the stream source); and in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline)." />
      <item value="Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -&gt; w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters:" />
      <item value="A stream pipeline, like the &quot;widgets&quot; example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried" />
      <item value="Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal." />
      <item value="A stream implementation is permitted significant latitude in optimizing the computation of the result. For example, a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation. This means that side-effects of behavioral parameters may not always be executed and should not be relied upon, unless otherwise specified (such as by the terminal operations forEach and forEachOrdered). (For a specific example of such an optimization, see the API note documented on the count operation. For more detail, see the side-effects section of the stream package documentation.)" />
      <item value="elide" />
      <item value="computation" />
      <item value="significant" />
      <item value="latitude" />
      <item value="permitted" />
      <item value="Returns the result of the computation when it is done. This method differs from get() in that abnormal completion results in RuntimeException or Error, not ExecutionException, and that interrupts of the calling thread do not cause the method to abruptly return by throwing InterruptedException." />
      <item value="Adds the given task to a submission queue at submitter's current queue, creating one if null or contended." />
      <item value="Execute a JDBC data access operation, implemented as callback action working on a JDBC Connection. This allows for implementing arbitrary data access operations, within Spring's managed JDBC environment: that is, participating in Spring-managed transactions and converting JDBC SQLExceptions into Spring's DataAccessException hierarchy" />
      <item value="initialization" />
      <item value="compatible" />
      <item value="Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers." />
      <item value="Election" />
      <item value="nd removes the head of this queue, waiting if necessary until an element becomes available." />
      <item value="The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The method does not need to concern itself with the state belonging to the object's superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput" />
      <item value="even when triggered by lifecycle interfaces like BeanFactoryAware" />
      <item value="Eagerly cache singletons to be able to resolve circular references" />
      <item value="Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds." />
      <item value="The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void." />
      <item value="Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects. Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader." />
      <item value="The specification strongly implies all configuration should be done during the creation of the handler object" />
      <item value="read Primordial Configuration" />
      <item value="The maximum size of array to allocate. Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit" />
      <item value="readlimit – the maximum limit of bytes that can be read before the mark position becomes invalid" />
      <item value="The Class instance representing the primitive type in" />
      <item value="Determines if the class or interface represented by this Class object is either the same as, or is a superclass or superinterface of, the class or interface represented by the specified Class parameter. It returns true if so; otherwise it returns false. If this Class object represents a primitive type, this method returns true if the specified Class parameter is exactly this Class object; otherwise it returns false." />
      <item value="primitive" />
      <item value="The comma separated list of tokens to include in the WAR before packaging. By default everything is included. This option may be used to implement the skinny WAR use case" />
      <item value="Cache mapping pairs of (key, sub-key) -&gt; value. Keys and values are weakly but sub-keys are strongly referenced. Keys are passed directly to get method which also takes a parameter. Sub-keys are calculated from keys and parameters using the subKeyFactory function passed to the constructor. Values are calculated from keys and parameters using the valueFactory function passed to the constructor. Keys can be null and are compared by identity while sub-keys returned by subKeyFactory or values returned by valueFactory can not be null. Sub-keys are compared using their equals method. Entries are expunged from cache lazily on each invocation to get, containsValue or size methods when the WeakReferences to keys are cleared. Cleared WeakReferences to individual values don't cause expunging, but such entries are logically treated as non-existent and trigger re-evaluation of valueFactory on request for their keysubKey" />
      <item value="The range of valid ports, from bind_port to end_port" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="263" />
        <entry key="ENGLISH" value="260" />
        <entry key="GERMAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1662368364209" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>