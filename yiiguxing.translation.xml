<application>
  <component name="AppStorage">
    <histories>
      <item value="A stream pipeline, like the &quot;widgets&quot; example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried" />
      <item value="Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal." />
      <item value="A stream implementation is permitted significant latitude in optimizing the computation of the result. For example, a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation. This means that side-effects of behavioral parameters may not always be executed and should not be relied upon, unless otherwise specified (such as by the terminal operations forEach and forEachOrdered). (For a specific example of such an optimization, see the API note documented on the count operation. For more detail, see the side-effects section of the stream package documentation.)" />
      <item value="elide" />
      <item value="computation" />
      <item value="significant" />
      <item value="latitude" />
      <item value="permitted" />
      <item value="Returns the result of the computation when it is done. This method differs from get() in that abnormal completion results in RuntimeException or Error, not ExecutionException, and that interrupts of the calling thread do not cause the method to abruptly return by throwing InterruptedException." />
      <item value="Adds the given task to a submission queue at submitter's current queue, creating one if null or contended." />
      <item value="Execute a JDBC data access operation, implemented as callback action working on a JDBC Connection. This allows for implementing arbitrary data access operations, within Spring's managed JDBC environment: that is, participating in Spring-managed transactions and converting JDBC SQLExceptions into Spring's DataAccessException hierarchy" />
      <item value="initialization" />
      <item value="compatible" />
      <item value="Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers." />
      <item value="Election" />
      <item value="nd removes the head of this queue, waiting if necessary until an element becomes available." />
      <item value="The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The method does not need to concern itself with the state belonging to the object's superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput" />
      <item value="even when triggered by lifecycle interfaces like BeanFactoryAware" />
      <item value="Eagerly cache singletons to be able to resolve circular references" />
      <item value="Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds." />
      <item value="The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void." />
      <item value="Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects. Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader." />
      <item value="The specification strongly implies all configuration should be done during the creation of the handler object" />
      <item value="read Primordial Configuration" />
      <item value="The maximum size of array to allocate. Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit" />
      <item value="readlimit â€“ the maximum limit of bytes that can be read before the mark position becomes invalid" />
      <item value="The Class instance representing the primitive type in" />
      <item value="Determines if the class or interface represented by this Class object is either the same as, or is a superclass or superinterface of, the class or interface represented by the specified Class parameter. It returns true if so; otherwise it returns false. If this Class object represents a primitive type, this method returns true if the specified Class parameter is exactly this Class object; otherwise it returns false." />
      <item value="primitive" />
      <item value="The comma separated list of tokens to include in the WAR before packaging. By default everything is included. This option may be used to implement the skinny WAR use case" />
      <item value="Cache mapping pairs of (key, sub-key) -&gt; value. Keys and values are weakly but sub-keys are strongly referenced. Keys are passed directly to get method which also takes a parameter. Sub-keys are calculated from keys and parameters using the subKeyFactory function passed to the constructor. Values are calculated from keys and parameters using the valueFactory function passed to the constructor. Keys can be null and are compared by identity while sub-keys returned by subKeyFactory or values returned by valueFactory can not be null. Sub-keys are compared using their equals method. Entries are expunged from cache lazily on each invocation to get, containsValue or size methods when the WeakReferences to keys are cleared. Cleared WeakReferences to individual values don't cause expunging, but such entries are logically treated as non-existent and trigger re-evaluation of valueFactory on request for their keysubKey" />
      <item value="The range of valid ports, from bind_port to end_port" />
      <item value="Minimum number of initial members to get a response from" />
      <item value="While String is the easiest way to manipulate chars ( search, substrings, etc), it is known to not be the most efficient solution - Strings are designed as immutable and secure objects" />
      <item value="Utilities" />
      <item value="Utilities to manipulate char chunks" />
      <item value="Preserve behavioral compatibility with AbstractCollection, even if c.contains() throws" />
      <item value="Externalizable" />
      <item value="canonical" />
      <item value="Initialize transaction synchronization as appropriate" />
      <item value="Standard transaction demarcation with getTransaction" />
      <item value="Semantics" />
      <item value="definitive" />
      <item value="We have fallen off list" />
      <item value="We have fallen off list. If tail is unchanged, it will also be off-list, in which case we need to jump to head, from which all live nodes are always reachable. Else the new tail is a better bet" />
      <item value="hop two nodes at a time" />
      <item value="the command to execute when the barrier is tripped" />
      <item value="Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http:en.wikipedia.orgwikiPoisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) factorial(k)). The first values are:" />
      <item value="Parses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="arses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="244" />
        <entry key="ENGLISH" value="241" />
        <entry key="GERMAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1650522891430" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>