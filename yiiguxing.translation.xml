<application>
  <component name="AppStorage">
    <histories>
      <item value="read Primordial Configuration" />
      <item value="The maximum size of array to allocate. Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit" />
      <item value="readlimit â€“ the maximum limit of bytes that can be read before the mark position becomes invalid" />
      <item value="The Class instance representing the primitive type in" />
      <item value="Determines if the class or interface represented by this Class object is either the same as, or is a superclass or superinterface of, the class or interface represented by the specified Class parameter. It returns true if so; otherwise it returns false. If this Class object represents a primitive type, this method returns true if the specified Class parameter is exactly this Class object; otherwise it returns false." />
      <item value="primitive" />
      <item value="The comma separated list of tokens to include in the WAR before packaging. By default everything is included. This option may be used to implement the skinny WAR use case" />
      <item value="Cache mapping pairs of (key, sub-key) -&gt; value. Keys and values are weakly but sub-keys are strongly referenced. Keys are passed directly to get method which also takes a parameter. Sub-keys are calculated from keys and parameters using the subKeyFactory function passed to the constructor. Values are calculated from keys and parameters using the valueFactory function passed to the constructor. Keys can be null and are compared by identity while sub-keys returned by subKeyFactory or values returned by valueFactory can not be null. Sub-keys are compared using their equals method. Entries are expunged from cache lazily on each invocation to get, containsValue or size methods when the WeakReferences to keys are cleared. Cleared WeakReferences to individual values don't cause expunging, but such entries are logically treated as non-existent and trigger re-evaluation of valueFactory on request for their keysubKey" />
      <item value="The range of valid ports, from bind_port to end_port" />
      <item value="Minimum number of initial members to get a response from" />
      <item value="While String is the easiest way to manipulate chars ( search, substrings, etc), it is known to not be the most efficient solution - Strings are designed as immutable and secure objects" />
      <item value="Utilities" />
      <item value="Utilities to manipulate char chunks" />
      <item value="Preserve behavioral compatibility with AbstractCollection, even if c.contains() throws" />
      <item value="Externalizable" />
      <item value="canonical" />
      <item value="Initialize transaction synchronization as appropriate" />
      <item value="Standard transaction demarcation with getTransaction" />
      <item value="Semantics" />
      <item value="definitive" />
      <item value="We have fallen off list" />
      <item value="We have fallen off list. If tail is unchanged, it will also be off-list, in which case we need to jump to head, from which all live nodes are always reachable. Else the new tail is a better bet" />
      <item value="hop two nodes at a time" />
      <item value="the command to execute when the barrier is tripped" />
      <item value="Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http:en.wikipedia.orgwikiPoisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) factorial(k)). The first values are:" />
      <item value="Parses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="arses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappers are added as it provides fail-fast statement validation" />
      <item value="sifts" />
      <item value="retain" />
      <item value="don't retain ref while waiting" />
      <item value="Constrains the values of all delays in the queue to be within Long.MAX_VALUE of each other, to avoid overflow in compareTo. This may occur if a task is eligible to be dequeued, but has not yet been, while some other task is added with a delay of Long.MAX_VALUE" />
      <item value="Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0" />
      <item value="We want to clear any interrupt we may have received from cancel(true). However, it is permissible to use interrupts as an independent mechanism for a task to communicate with its caller, and there is no way to clear only the cancellation interrupt" />
      <item value="Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled" />
      <item value="Treiber stack" />
      <item value="Treiber" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us" />
      <item value="It is possible for our interrupter to stall before getting a chance to interrupt us. Let's spin-wait patiently" />
      <item value="wait out pending interrupt" />
      <item value="Ensures that any interrupt from a possible cancel(true) is only delivered to a task while in run or runAndReset" />
      <item value="culling" />
      <item value="Are workers subject to culling" />
      <item value="If abrupt, then workerCount wasn't adjusted" />
      <item value="Abruptly" />
      <item value="This operation has memory semantics" />
      <item value="precheck that t is startable" />
      <item value="If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we recheck state and if necessary roll back the enqueuing if stopped, or start a new thread if there are none" />
      <item value="Inserts the specified element into this queue, if another thread is waiting to receive it" />
      <item value="completed Abruptly" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="220" />
        <entry key="ENGLISH" value="217" />
        <entry key="GERMAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="ROMANIAN" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ESPERANTO" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1639192088868" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200323000403253" />
      </app-key>
    </option>
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="1d827835062ae583" />
      </youdao-translate>
    </option>
  </component>
</application>